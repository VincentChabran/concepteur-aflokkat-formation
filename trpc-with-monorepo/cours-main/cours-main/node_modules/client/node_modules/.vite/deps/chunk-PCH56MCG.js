// ../../node_modules/@trpc/server/dist/observable-ade1bad8.mjs
function identity(x) {
  return x;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce((prev, fn) => fn(prev), input);
  };
}
function observable(subscribe) {
  const self = {
    subscribe(observer) {
      let teardownRef = null;
      let isDone = false;
      let unsubscribed = false;
      let teardownImmediately = false;
      function unsubscribe() {
        if (teardownRef === null) {
          teardownImmediately = true;
          return;
        }
        if (unsubscribed) {
          return;
        }
        unsubscribed = true;
        if (typeof teardownRef === "function") {
          teardownRef();
        } else if (teardownRef) {
          teardownRef.unsubscribe();
        }
      }
      teardownRef = subscribe({
        next(value) {
          var _a;
          if (isDone) {
            return;
          }
          (_a = observer.next) == null ? void 0 : _a.call(observer, value);
        },
        error(err) {
          var _a;
          if (isDone) {
            return;
          }
          isDone = true;
          (_a = observer.error) == null ? void 0 : _a.call(observer, err);
          unsubscribe();
        },
        complete() {
          var _a;
          if (isDone) {
            return;
          }
          isDone = true;
          (_a = observer.complete) == null ? void 0 : _a.call(observer);
          unsubscribe();
        }
      });
      if (teardownImmediately) {
        unsubscribe();
      }
      return {
        unsubscribe
      };
    },
    pipe(...operations) {
      return pipeFromArray(operations)(self);
    }
  };
  return self;
}

// ../../node_modules/@trpc/server/dist/observable/index.mjs
function share(_opts) {
  return (originalObserver) => {
    let refCount = 0;
    let subscription = null;
    const observers = [];
    function startIfNeeded() {
      if (subscription) {
        return;
      }
      subscription = originalObserver.subscribe({
        next(value) {
          var _a;
          for (const observer of observers) {
            (_a = observer.next) == null ? void 0 : _a.call(observer, value);
          }
        },
        error(error) {
          var _a;
          for (const observer of observers) {
            (_a = observer.error) == null ? void 0 : _a.call(observer, error);
          }
        },
        complete() {
          var _a;
          for (const observer of observers) {
            (_a = observer.complete) == null ? void 0 : _a.call(observer);
          }
        }
      });
    }
    function resetIfNeeded() {
      if (refCount === 0 && subscription) {
        const _sub = subscription;
        subscription = null;
        _sub.unsubscribe();
      }
    }
    return {
      subscribe(observer) {
        refCount++;
        observers.push(observer);
        startIfNeeded();
        return {
          unsubscribe() {
            refCount--;
            resetIfNeeded();
            const index = observers.findIndex((v) => v === observer);
            if (index > -1) {
              observers.splice(index, 1);
            }
          }
        };
      }
    };
  };
}
function tap(observer) {
  return (originalObserver) => {
    return {
      subscribe(observer2) {
        return originalObserver.subscribe({
          next(v) {
            var _a, _b;
            (_a = observer.next) == null ? void 0 : _a.call(observer, v);
            (_b = observer2.next) == null ? void 0 : _b.call(observer2, v);
          },
          error(v) {
            var _a, _b;
            (_a = observer.error) == null ? void 0 : _a.call(observer, v);
            (_b = observer2.error) == null ? void 0 : _b.call(observer2, v);
          },
          complete() {
            var _a, _b;
            (_a = observer.complete) == null ? void 0 : _a.call(observer);
            (_b = observer2.complete) == null ? void 0 : _b.call(observer2);
          }
        });
      }
    };
  };
}
var ObservableAbortError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ObservableAbortError";
    Object.setPrototypeOf(this, ObservableAbortError.prototype);
  }
};
function observableToPromise(observable2) {
  let abort;
  const promise = new Promise((resolve, reject) => {
    let isDone = false;
    function onDone() {
      if (isDone) {
        return;
      }
      isDone = true;
      reject(new ObservableAbortError("This operation was aborted."));
      obs$.unsubscribe();
    }
    const obs$ = observable2.subscribe({
      next(data) {
        isDone = true;
        resolve(data);
        onDone();
      },
      error(data) {
        isDone = true;
        reject(data);
        onDone();
      },
      complete() {
        isDone = true;
        onDone();
      }
    });
    abort = onDone;
  });
  return {
    promise,
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    abort
  };
}

// ../../node_modules/@trpc/client/dist/transformResult-6fb67924.mjs
var TRPCClientError = class extends Error {
  static from(cause, opts = {}) {
    if (!(cause instanceof Error)) {
      return new TRPCClientError(cause.error.message ?? "", {
        ...opts,
        cause: void 0,
        result: cause
      });
    }
    if (cause.name === "TRPCClientError") {
      return cause;
    }
    return new TRPCClientError(cause.message, {
      ...opts,
      cause,
      result: null
    });
  }
  constructor(message, opts) {
    var _a, _b;
    const cause = opts == null ? void 0 : opts.cause;
    super(message, {
      cause
    });
    this.meta = opts == null ? void 0 : opts.meta;
    this.cause = cause;
    this.shape = (_a = opts == null ? void 0 : opts.result) == null ? void 0 : _a.error;
    this.data = (_b = opts == null ? void 0 : opts.result) == null ? void 0 : _b.error.data;
    this.name = "TRPCClientError";
    Object.setPrototypeOf(this, TRPCClientError.prototype);
  }
};
function transformResultInner(response, runtime) {
  if ("error" in response) {
    const error = runtime.transformer.deserialize(response.error);
    return {
      ok: false,
      error: {
        ...response,
        error
      }
    };
  }
  const result = {
    ...response.result,
    ...(!response.result.type || response.result.type === "data") && {
      type: "data",
      data: runtime.transformer.deserialize(response.result.data)
    }
  };
  return {
    ok: true,
    result
  };
}
function isObject(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
function transformResult(response, runtime) {
  let result;
  try {
    result = transformResultInner(response, runtime);
  } catch (err) {
    throw new TRPCClientError("Unable to transform response from server");
  }
  if (!result.ok && (!isObject(result.error.error) || typeof result.error.error.code !== "number")) {
    throw new TRPCClientError("Badly formatted response from server");
  }
  if (result.ok && !isObject(result.result)) {
    throw new TRPCClientError("Badly formatted response from server");
  }
  return result;
}

// ../../node_modules/@trpc/client/dist/splitLink-4c75f7be.mjs
function createChain(opts) {
  return observable((observer) => {
    function execute(index = 0, op = opts.op) {
      const next = opts.links[index];
      if (!next) {
        throw new Error("No more links to execute - did you forget to add an ending link?");
      }
      const subscription = next({
        op,
        next(nextOp) {
          const nextObserver = execute(index + 1, nextOp);
          return nextObserver;
        }
      });
      return subscription;
    }
    const obs$ = execute();
    return obs$.subscribe(observer);
  });
}
function asArray(value) {
  return Array.isArray(value) ? value : [
    value
  ];
}
function splitLink(opts) {
  return (runtime) => {
    const yes = asArray(opts.true).map((link) => link(runtime));
    const no = asArray(opts.false).map((link) => link(runtime));
    return (props) => {
      return observable((observer) => {
        const links = opts.condition(props.op) ? yes : no;
        return createChain({
          op: props.op,
          links
        }).subscribe(observer);
      });
    };
  };
}

// ../../node_modules/@trpc/server/dist/index-972002da.mjs
var noop = () => {
};
function createInnerProxy(callback, path) {
  const proxy = new Proxy(noop, {
    get(_obj, key) {
      if (typeof key !== "string" || key === "then") {
        return void 0;
      }
      return createInnerProxy(callback, [
        ...path,
        key
      ]);
    },
    apply(_1, _2, args) {
      return callback({
        args,
        path
      });
    }
  });
  return proxy;
}
var createRecursiveProxy = (callback) => createInnerProxy(callback, []);
var createFlatProxy = (callback) => {
  return new Proxy(noop, {
    get(_obj, name) {
      if (typeof name !== "string" || name === "then") {
        return void 0;
      }
      return callback(name);
    }
  });
};

// ../../node_modules/@trpc/client/dist/httpUtils-9b676ab4.mjs
var isFunction = (fn) => typeof fn === "function";
function _bind(fn, thisArg) {
  return isFunction(fn.bind) ? fn.bind(thisArg) : fn;
}
function getFetch(customFetchImpl) {
  if (customFetchImpl) {
    return customFetchImpl;
  }
  if (typeof window !== "undefined" && isFunction(window.fetch)) {
    return _bind(window.fetch, window);
  }
  if (typeof globalThis !== "undefined" && isFunction(globalThis.fetch)) {
    return _bind(globalThis.fetch, globalThis);
  }
  throw new Error("No fetch implementation found");
}
function getAbortController(customAbortControllerImpl) {
  if (customAbortControllerImpl) {
    return customAbortControllerImpl;
  }
  if (typeof window !== "undefined" && window.AbortController) {
    return window.AbortController;
  }
  if (typeof globalThis !== "undefined" && globalThis.AbortController) {
    return globalThis.AbortController;
  }
  return null;
}
function resolveHTTPLinkOptions(opts) {
  const headers = opts.headers || (() => ({}));
  return {
    url: opts.url,
    fetch: getFetch(opts.fetch),
    AbortController: getAbortController(opts.AbortController),
    headers: typeof headers === "function" ? headers : () => headers
  };
}
function arrayToDict(array) {
  const dict = {};
  for (let index = 0; index < array.length; index++) {
    const element = array[index];
    dict[index] = element;
  }
  return dict;
}
var METHOD = {
  query: "GET",
  mutation: "POST"
};
function getInput(opts) {
  return "input" in opts ? opts.runtime.transformer.serialize(opts.input) : arrayToDict(opts.inputs.map((_input) => opts.runtime.transformer.serialize(_input)));
}
function getUrl(opts) {
  let url = opts.url + "/" + opts.path;
  const queryParts = [];
  if ("inputs" in opts) {
    queryParts.push("batch=1");
  }
  if (opts.type === "query") {
    const input = getInput(opts);
    if (input !== void 0) {
      queryParts.push(`input=${encodeURIComponent(JSON.stringify(input))}`);
    }
  }
  if (queryParts.length) {
    url += "?" + queryParts.join("&");
  }
  return url;
}
function getBody(opts) {
  if (opts.type === "query") {
    return void 0;
  }
  const input = getInput(opts);
  return input !== void 0 ? JSON.stringify(input) : void 0;
}
function httpRequest(opts) {
  const { type } = opts;
  const ac = opts.AbortController ? new opts.AbortController() : null;
  const promise = new Promise((resolve, reject) => {
    const url = getUrl(opts);
    const body = getBody(opts);
    const meta = {};
    Promise.resolve(opts.headers()).then((headers) => {
      if (type === "subscription") {
        throw new Error("Subscriptions should use wsLink");
      }
      return opts.fetch(url, {
        method: METHOD[type],
        signal: ac == null ? void 0 : ac.signal,
        body,
        headers: {
          "content-type": "application/json",
          ...headers
        }
      });
    }).then((_res) => {
      meta.response = _res;
      return _res.json();
    }).then((json) => {
      resolve({
        json,
        meta
      });
    }).catch(reject);
  });
  const cancel = () => {
    ac == null ? void 0 : ac.abort();
  };
  return {
    promise,
    cancel
  };
}

// ../../node_modules/@trpc/client/dist/links/httpBatchLink.mjs
var throwFatalError = () => {
  throw new Error("Something went wrong. Please submit an issue at https://github.com/trpc/trpc/issues/new");
};
function dataLoader(batchLoader) {
  let pendingItems = null;
  let dispatchTimer = null;
  const destroyTimerAndPendingItems = () => {
    clearTimeout(dispatchTimer);
    dispatchTimer = null;
    pendingItems = null;
  };
  function groupItems(items) {
    const groupedItems = [
      []
    ];
    let index = 0;
    while (true) {
      const item = items[index];
      if (!item) {
        break;
      }
      const lastGroup = groupedItems[groupedItems.length - 1];
      if (item.aborted) {
        item.reject(new Error("Aborted"));
        index++;
        continue;
      }
      const isValid = batchLoader.validate(lastGroup.concat(item).map((it) => it.key));
      if (isValid) {
        lastGroup.push(item);
        index++;
        continue;
      }
      if (lastGroup.length === 0) {
        item.reject(new Error("Input is too big for a single dispatch"));
        index++;
        continue;
      }
      groupedItems.push([]);
    }
    return groupedItems;
  }
  function dispatch() {
    const groupedItems = groupItems(pendingItems);
    destroyTimerAndPendingItems();
    for (const items of groupedItems) {
      if (!items.length) {
        continue;
      }
      const batch = {
        items,
        cancel: throwFatalError
      };
      for (const item of items) {
        item.batch = batch;
      }
      const { promise, cancel } = batchLoader.fetch(batch.items.map((_item) => _item.key));
      batch.cancel = cancel;
      promise.then((result) => {
        for (let i = 0; i < result.length; i++) {
          const value = result[i];
          const item = batch.items[i];
          item.resolve(value);
          item.batch = null;
        }
      }).catch((cause) => {
        for (const item of batch.items) {
          item.reject(cause);
          item.batch = null;
        }
      });
    }
  }
  function load(key) {
    const item = {
      aborted: false,
      key,
      batch: null,
      resolve: throwFatalError,
      reject: throwFatalError
    };
    const promise = new Promise((resolve, reject) => {
      item.reject = reject;
      item.resolve = resolve;
      if (!pendingItems) {
        pendingItems = [];
      }
      pendingItems.push(item);
    });
    if (!dispatchTimer) {
      dispatchTimer = setTimeout(dispatch);
    }
    const cancel = () => {
      var _a;
      item.aborted = true;
      if ((_a = item.batch) == null ? void 0 : _a.items.every((item2) => item2.aborted)) {
        item.batch.cancel();
        item.batch = null;
      }
    };
    return {
      promise,
      cancel
    };
  }
  return {
    load
  };
}
function httpBatchLink(opts) {
  const resolvedOpts = resolveHTTPLinkOptions(opts);
  return (runtime) => {
    const maxURLLength = opts.maxURLLength || Infinity;
    const batchLoader = (type) => {
      const validate = (batchOps) => {
        if (maxURLLength === Infinity) {
          return true;
        }
        const path = batchOps.map((op) => op.path).join(",");
        const inputs = batchOps.map((op) => op.input);
        const url = getUrl({
          ...resolvedOpts,
          runtime,
          type,
          path,
          inputs
        });
        return url.length <= maxURLLength;
      };
      const fetch = (batchOps) => {
        const path = batchOps.map((op) => op.path).join(",");
        const inputs = batchOps.map((op) => op.input);
        const { promise, cancel } = httpRequest({
          ...resolvedOpts,
          runtime,
          type,
          path,
          inputs
        });
        return {
          promise: promise.then((res) => {
            const resJSON = Array.isArray(res.json) ? res.json : batchOps.map(() => res.json);
            const result = resJSON.map((item) => ({
              meta: res.meta,
              json: item
            }));
            return result;
          }),
          cancel
        };
      };
      return {
        validate,
        fetch
      };
    };
    const query = dataLoader(batchLoader("query"));
    const mutation = dataLoader(batchLoader("mutation"));
    const subscription = dataLoader(batchLoader("subscription"));
    const loaders = {
      query,
      subscription,
      mutation
    };
    return ({ op }) => {
      return observable((observer) => {
        const loader = loaders[op.type];
        const { promise, cancel } = loader.load(op);
        promise.then((res) => {
          const transformed = transformResult(res.json, runtime);
          if (!transformed.ok) {
            observer.error(TRPCClientError.from(transformed.error, {
              meta: res.meta
            }));
            return;
          }
          observer.next({
            context: res.meta,
            result: transformed.result
          });
          observer.complete();
        }).catch((err) => observer.error(TRPCClientError.from(err)));
        return () => {
          cancel();
        };
      });
    };
  };
}

// ../../node_modules/@trpc/client/dist/links/httpLink.mjs
function httpLink(opts) {
  const resolvedOpts = resolveHTTPLinkOptions(opts);
  return (runtime) => ({ op }) => observable((observer) => {
    const { path, input, type } = op;
    const { promise, cancel } = httpRequest({
      ...resolvedOpts,
      runtime,
      type,
      path,
      input
    });
    promise.then((res) => {
      const transformed = transformResult(res.json, runtime);
      if (!transformed.ok) {
        observer.error(TRPCClientError.from(transformed.error, {
          meta: res.meta
        }));
        return;
      }
      observer.next({
        context: res.meta,
        result: transformed.result
      });
      observer.complete();
    }).catch((cause) => observer.error(TRPCClientError.from(cause)));
    return () => {
      cancel();
    };
  });
}

// ../../node_modules/@trpc/client/dist/links/loggerLink.mjs
var palette = {
  query: [
    "72e3ff",
    "3fb0d8"
  ],
  mutation: [
    "c5a3fc",
    "904dfc"
  ],
  subscription: [
    "ff49e1",
    "d83fbe"
  ]
};
var defaultLogger = (c = console) => (props) => {
  const { direction, input, type, path, context, id } = props;
  const [light, dark] = palette[type];
  const css = `
    background-color: #${direction === "up" ? light : dark}; 
    color: ${direction === "up" ? "black" : "white"};
    padding: 2px;
  `;
  const parts = [
    "%c",
    direction === "up" ? ">>" : "<<",
    type,
    `#${id}`,
    `%c${path}%c`,
    "%O"
  ];
  const args = [
    css,
    `${css}; font-weight: bold;`,
    `${css}; font-weight: normal;`
  ];
  if (props.direction === "up") {
    args.push({
      input,
      context
    });
  } else {
    args.push({
      input,
      result: props.result,
      elapsedMs: props.elapsedMs,
      context
    });
  }
  const fn = props.direction === "down" && props.result && (props.result instanceof Error || "error" in props.result.result) ? "error" : "log";
  c[fn].apply(null, [
    parts.join(" ")
  ].concat(args));
};
function loggerLink(opts = {}) {
  const { enabled = () => true } = opts;
  const { logger = defaultLogger(opts.console) } = opts;
  return () => {
    return ({ op, next }) => {
      return observable((observer) => {
        enabled({
          ...op,
          direction: "up"
        }) && logger({
          ...op,
          direction: "up"
        });
        const requestStartTime = Date.now();
        function logResult(result) {
          const elapsedMs = Date.now() - requestStartTime;
          enabled({
            ...op,
            direction: "down",
            result
          }) && logger({
            ...op,
            direction: "down",
            elapsedMs,
            result
          });
        }
        return next(op).pipe(tap({
          next(result) {
            logResult(result);
          },
          error(result) {
            logResult(result);
          }
        })).subscribe(observer);
      });
    };
  };
}

// ../../node_modules/@trpc/client/dist/links/wsLink.mjs
var retryDelay = (attemptIndex) => attemptIndex === 0 ? 0 : Math.min(1e3 * 2 ** attemptIndex, 3e4);
function createWSClient(opts) {
  const { url, WebSocket: WebSocketImpl = WebSocket, retryDelayMs: retryDelayFn = retryDelay, onOpen, onClose } = opts;
  if (!WebSocketImpl) {
    throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
  }
  let outgoing = [];
  const pendingRequests = /* @__PURE__ */ Object.create(null);
  let connectAttempt = 0;
  let dispatchTimer = null;
  let connectTimer = null;
  let activeConnection = createWS();
  let state = "connecting";
  function dispatch() {
    if (state !== "open" || dispatchTimer) {
      return;
    }
    dispatchTimer = setTimeout(() => {
      dispatchTimer = null;
      if (outgoing.length === 1) {
        activeConnection.send(JSON.stringify(outgoing.pop()));
      } else {
        activeConnection.send(JSON.stringify(outgoing));
      }
      outgoing = [];
    });
  }
  function tryReconnect() {
    if (connectTimer || state === "closed") {
      return;
    }
    const timeout = retryDelayFn(connectAttempt++);
    reconnectInMs(timeout);
  }
  function reconnect() {
    state = "connecting";
    const oldConnection = activeConnection;
    activeConnection = createWS();
    closeIfNoPending(oldConnection);
  }
  function reconnectInMs(ms) {
    if (connectTimer) {
      return;
    }
    state = "connecting";
    connectTimer = setTimeout(reconnect, ms);
  }
  function closeIfNoPending(conn) {
    const hasPendingRequests = Object.values(pendingRequests).some((p) => p.ws === conn);
    if (!hasPendingRequests) {
      conn.close();
    }
  }
  function resumeSubscriptionOnReconnect(req) {
    if (outgoing.some((r) => r.id === req.op.id)) {
      return;
    }
    request(req.op, req.callbacks);
  }
  function createWS() {
    const urlString = typeof url === "function" ? url() : url;
    const conn = new WebSocketImpl(urlString);
    clearTimeout(connectTimer);
    connectTimer = null;
    conn.addEventListener("open", () => {
      if (conn !== activeConnection) {
        return;
      }
      connectAttempt = 0;
      state = "open";
      onOpen == null ? void 0 : onOpen();
      dispatch();
    });
    conn.addEventListener("error", () => {
      if (conn === activeConnection) {
        tryReconnect();
      }
    });
    const handleIncomingRequest = (req) => {
      if (req.method === "reconnect" && conn === activeConnection) {
        if (state === "open") {
          onClose == null ? void 0 : onClose();
        }
        reconnect();
        for (const pendingReq of Object.values(pendingRequests)) {
          if (pendingReq.type === "subscription") {
            resumeSubscriptionOnReconnect(pendingReq);
          }
        }
      }
    };
    const handleIncomingResponse = (data) => {
      var _a, _b;
      const req = data.id !== null && pendingRequests[data.id];
      if (!req) {
        return;
      }
      (_b = (_a = req.callbacks).next) == null ? void 0 : _b.call(_a, data);
      if (req.ws !== activeConnection && conn === activeConnection) {
        const oldWs = req.ws;
        req.ws = activeConnection;
        closeIfNoPending(oldWs);
      }
      if ("result" in data && data.result.type === "stopped" && conn === activeConnection) {
        req.callbacks.complete();
      }
    };
    conn.addEventListener("message", ({ data }) => {
      const msg = JSON.parse(data);
      if ("method" in msg) {
        handleIncomingRequest(msg);
      } else {
        handleIncomingResponse(msg);
      }
      if (conn !== activeConnection || state === "closed") {
        closeIfNoPending(conn);
      }
    });
    conn.addEventListener("close", ({ code }) => {
      var _a, _b, _c, _d;
      if (state === "open") {
        onClose == null ? void 0 : onClose({
          code
        });
      }
      if (activeConnection === conn) {
        tryReconnect();
      }
      for (const [key, req] of Object.entries(pendingRequests)) {
        if (req.ws !== conn) {
          continue;
        }
        if (state === "closed") {
          delete pendingRequests[key];
          (_b = (_a = req.callbacks).complete) == null ? void 0 : _b.call(_a);
          continue;
        }
        if (req.type === "subscription") {
          resumeSubscriptionOnReconnect(req);
        } else {
          delete pendingRequests[key];
          (_d = (_c = req.callbacks).error) == null ? void 0 : _d.call(_c, TRPCClientError.from(new TRPCWebSocketClosedError("WebSocket closed prematurely")));
        }
      }
    });
    return conn;
  }
  function request(op, callbacks) {
    const { type, input, path, id } = op;
    const envelope = {
      id,
      method: type,
      params: {
        input,
        path
      }
    };
    pendingRequests[id] = {
      ws: activeConnection,
      type,
      callbacks,
      op
    };
    outgoing.push(envelope);
    dispatch();
    return () => {
      var _a, _b;
      const callbacks2 = (_a = pendingRequests[id]) == null ? void 0 : _a.callbacks;
      delete pendingRequests[id];
      outgoing = outgoing.filter((msg) => msg.id !== id);
      (_b = callbacks2 == null ? void 0 : callbacks2.complete) == null ? void 0 : _b.call(callbacks2);
      if (activeConnection.readyState === WebSocketImpl.OPEN && op.type === "subscription") {
        outgoing.push({
          id,
          method: "subscription.stop"
        });
        dispatch();
      }
    };
  }
  return {
    close: () => {
      state = "closed";
      onClose == null ? void 0 : onClose();
      closeIfNoPending(activeConnection);
      clearTimeout(connectTimer);
      connectTimer = null;
    },
    request,
    getConnection() {
      return activeConnection;
    }
  };
}
var TRPCWebSocketClosedError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TRPCWebSocketClosedError";
    Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);
  }
};
var TRPCSubscriptionEndedError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TRPCSubscriptionEndedError";
    Object.setPrototypeOf(this, TRPCSubscriptionEndedError.prototype);
  }
};
function wsLink(opts) {
  return (runtime) => {
    const { client } = opts;
    return ({ op }) => {
      return observable((observer) => {
        const { type, path, id, context } = op;
        const input = runtime.transformer.serialize(op.input);
        let isDone = false;
        const unsub = client.request({
          type,
          path,
          input,
          id,
          context
        }, {
          error(err) {
            isDone = true;
            observer.error(err);
            unsub();
          },
          complete() {
            if (!isDone) {
              isDone = true;
              observer.error(TRPCClientError.from(new TRPCSubscriptionEndedError("Operation ended prematurely")));
            } else {
              observer.complete();
            }
          },
          next(message) {
            const transformed = transformResult(message, runtime);
            if (!transformed.ok) {
              observer.error(TRPCClientError.from(transformed.error));
              return;
            }
            observer.next({
              result: transformed.result
            });
            if (op.type !== "subscription") {
              isDone = true;
              unsub();
              observer.complete();
            }
          }
        });
        return () => {
          isDone = true;
          unsub();
        };
      });
    };
  };
}

// ../../node_modules/@trpc/client/dist/index.mjs
var TRPCUntypedClient = class {
  $request({ type, input, path, context = {} }) {
    const chain$ = createChain({
      links: this.links,
      op: {
        id: ++this.requestId,
        type,
        path,
        input,
        context
      }
    });
    return chain$.pipe(share());
  }
  requestAsPromise(opts) {
    const req$ = this.$request(opts);
    const { promise, abort } = observableToPromise(req$);
    const abortablePromise = new Promise((resolve, reject) => {
      var _a;
      (_a = opts.signal) == null ? void 0 : _a.addEventListener("abort", abort);
      promise.then((envelope) => {
        resolve(envelope.result.data);
      }).catch((err) => {
        reject(TRPCClientError.from(err));
      });
    });
    return abortablePromise;
  }
  query(path, input, opts) {
    return this.requestAsPromise({
      type: "query",
      path,
      input,
      context: opts == null ? void 0 : opts.context,
      signal: opts == null ? void 0 : opts.signal
    });
  }
  mutation(path, input, opts) {
    return this.requestAsPromise({
      type: "mutation",
      path,
      input,
      context: opts == null ? void 0 : opts.context,
      signal: opts == null ? void 0 : opts.signal
    });
  }
  subscription(path, input, opts) {
    const observable$ = this.$request({
      type: "subscription",
      path,
      input,
      context: opts == null ? void 0 : opts.context
    });
    return observable$.subscribe({
      next(envelope) {
        var _a, _b, _c;
        if (envelope.result.type === "started") {
          (_a = opts.onStarted) == null ? void 0 : _a.call(opts);
        } else if (envelope.result.type === "stopped") {
          (_b = opts.onStopped) == null ? void 0 : _b.call(opts);
        } else {
          (_c = opts.onData) == null ? void 0 : _c.call(opts, envelope.result.data);
        }
      },
      error(err) {
        var _a;
        (_a = opts.onError) == null ? void 0 : _a.call(opts, err);
      },
      complete() {
        var _a;
        (_a = opts.onComplete) == null ? void 0 : _a.call(opts);
      }
    });
  }
  constructor(opts) {
    this.requestId = 0;
    function getTransformer() {
      const transformer = opts.transformer;
      if (!transformer)
        return {
          serialize: (data) => data,
          deserialize: (data) => data
        };
      if ("input" in transformer)
        return {
          serialize: transformer.input.serialize,
          deserialize: transformer.output.deserialize
        };
      return transformer;
    }
    this.runtime = {
      transformer: getTransformer()
    };
    this.links = opts.links.map((link) => link(this.runtime));
  }
};
function createTRPCUntypedClient(opts) {
  const client = new TRPCUntypedClient(opts);
  return client;
}
function createTRPCClient(opts) {
  const client = new TRPCUntypedClient(opts);
  return client;
}
var clientCallTypeMap = {
  query: "query",
  mutate: "mutation",
  subscribe: "subscription"
};
function createTRPCClientProxy(client) {
  return createFlatProxy((key) => {
    if (client.hasOwnProperty(key)) {
      return client[key];
    }
    return createRecursiveProxy(({ path, args }) => {
      const pathCopy = [
        key,
        ...path
      ];
      const clientCallType = pathCopy.pop();
      const procedureType = clientCallTypeMap[clientCallType];
      const fullPath = pathCopy.join(".");
      return client[procedureType](fullPath, ...args);
    });
  });
}
function createTRPCProxyClient(opts) {
  const client = new TRPCUntypedClient(opts);
  const proxy = createTRPCClientProxy(client);
  return proxy;
}

export {
  TRPCClientError,
  splitLink,
  createRecursiveProxy,
  createFlatProxy,
  getFetch,
  httpBatchLink,
  httpLink,
  loggerLink,
  createWSClient,
  wsLink,
  createTRPCUntypedClient,
  createTRPCClient,
  createTRPCClientProxy,
  createTRPCProxyClient
};
/*! Bundled license information:

@trpc/client/dist/httpUtils-9b676ab4.mjs:
  (* istanbul ignore if -- @preserve *)

@trpc/client/dist/links/wsLink.mjs:
  (* istanbul ignore next -- @preserve *)
*/
//# sourceMappingURL=chunk-PCH56MCG.js.map
